/*
Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include "LIEF/LIEF.h"

#include <err.h>
#include <stdio.h>
#include <errno.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <seccomp.h>
#include <inttypes.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <sys/prctl.h>
#include <sys/syscall.h>

#define MAX_SIZE        0x1000
#define MARKER          "deadbeef"
#define MARKER_SIZE     (sizeof(MARKER) - 1)

static int readall(int fd, void *buf, size_t count)
{
  ssize_t n;
  size_t i;
  char *p;

  p = buf;
  i = count;
  while (i > 0) {
    n = read(fd, p, i);
    if (n == 0) {
      warnx("read failed");
      return -1;
    } else if (n == -1) {
      if (errno == EINTR)
        continue;
      warn("read failed");
      return -1;
    }
    i -= n;
    p += n;

    if (count - i >= MARKER_SIZE) {
      if (memcmp(p - MARKER_SIZE, MARKER, MARKER_SIZE) == 0) {
        printf("[*] received %lu bytes\n", count - i);
        break;
      }
    }
  }

  return count - i;
}

static int writeall(int fd, void *buf, size_t count)
{
  ssize_t n;
  size_t i;
  char *p;

  p = buf;
  i = count;
  while (i > 0) {
    n = write(fd, p, i);
    if (n == 0) {
      warnx("write failed");
      return -1;
    } else if (n == -1) {
      if (errno == EINTR)
        continue;
      warn("write failed");
      return -1;
    }
    i -= n;
    p += n;
  }

  return 0;
}

static int recvfile(int infd, char *template)
{
  char buf[MAX_SIZE];
  ssize_t count;
  int outfd;

  count = readall(infd, buf, sizeof(buf));
  if (count == -1)
    return -1;

  outfd = mkstemp(template);
  if (outfd == -1) {
    warn("mkstemp");
    return -1;
  }

  if (writeall(outfd, buf, count) != 0) {
    close(outfd);
    return -1;
  }

  if (fchmod(outfd, 0500) != 0) {
    warn("fchmod");
    close(outfd);
    return -1;
  }

  close(outfd);

  return 0;
}

static unsigned long get_mmap_min_addr(unsigned long *mmap_min_addr)
{
  FILE *fp;
  int ret;

  fp = fopen("/proc/sys/vm/mmap_min_addr", "r");
  if (fp == NULL) {
    warn("failed to open \"/proc/sys/vm/mmap_min_addr\"");
    return -1;
  }

  ret = (fscanf(fp, "%lu", mmap_min_addr) != 1);
  fclose(fp);

  return ret;
}

static int install_syscall_filter(unsigned long mmap_min_addr)
{
  int allowed_syscall[] = {
    SCMP_SYS(rt_sigreturn),
    SCMP_SYS(rt_sigaction),
    SCMP_SYS(rt_sigprocmask),
    SCMP_SYS(sigreturn),
    SCMP_SYS(exit_group),
    SCMP_SYS(exit),
    SCMP_SYS(brk),
    SCMP_SYS(access),
    SCMP_SYS(fstat),
    SCMP_SYS(write),
    SCMP_SYS(close),
    SCMP_SYS(mprotect),
    SCMP_SYS(arch_prctl),
    SCMP_SYS(munmap),
    SCMP_SYS(fstat),
    SCMP_SYS(readlink),
    SCMP_SYS(uname),
  };
  scmp_filter_ctx ctx;
  unsigned int i;
  int ret;

  ctx = seccomp_init(SCMP_ACT_KILL);
  if (ctx == NULL) {
    warn("seccomp_init");
    return -1;
  }

  for (i = 0; i < sizeof(allowed_syscall) / sizeof(int); i++) {
    if (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, allowed_syscall[i], 0) != 0) {
      warn("seccomp_rule_add");
      ret = -1;
      goto out;
    }
  }

  /* prevent mmap to map mmap_min_addr */
  if (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(mmap), 1,
                       SCMP_A0(SCMP_CMP_GE, mmap_min_addr + PAGE_SIZE)) != 0) {
    warn("seccomp_rule_add");
    ret = -1;
    goto out;
  }

  /* first execve argument (filename) must be mapped at mmap_min_addr */
  if (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(execve), 1,
                       SCMP_A0(SCMP_CMP_EQ, mmap_min_addr)) != 0) {
    warn("seccomp_rule_add");
    ret = -1;
    goto out;
  }

  puts("[*] seccomp-bpf filters installed");

  ret = seccomp_load(ctx);
  if (ret != 0)
    warn("seccomp_load");

out:
  seccomp_release(ctx);
  return ret;
}

static char *setup_sandbox(unsigned long mmap_min_addr)
{
  int flags, prot;
  void *p;

  flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED;
  prot = PROT_READ | PROT_WRITE;
  p = mmap((void *)mmap_min_addr, PAGE_SIZE, prot, flags, -1, 0);
  if (p == MAP_FAILED) {
    warn("mmap");
    return NULL;
  }

  if (install_syscall_filter(mmap_min_addr) != 0) {
    if (munmap(p, PAGE_SIZE) != 0)
      warn("munmap");
    return NULL;
  }

  return (char *)p;
}

static void execute(char *filename, unsigned long mmap_min_addr)
{
  if (prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0) != 0)
    err(EXIT_FAILURE, "prctl(PR_SET_PDEATHSIG)");

  char *p = setup_sandbox(mmap_min_addr);
  if (p == NULL)
    exit(EXIT_FAILURE);

  strncpy(p, filename, PAGE_SIZE);
  p[PAGE_SIZE-1] = '\x00';

  printf("[*] let's execute \"%s\" in that sandbox\n", filename);
  if (execl(p, filename, NULL) != 0)
    err(EXIT_FAILURE, "execl of \"%s\" failed", p);

  /* never reached */
  exit(EXIT_SUCCESS);
}

static int elf_check(const char *filename, unsigned long mmap_min_addr)
{
  Elf_Binary_t *elf_binary = elf_parse(filename);
  if (elf_binary == NULL) {
    warnx("failed to parse ELF binary");
    return -1;
  }

  Elf_Header_t header = elf_binary->header;
  uint8_t *identity = header.identity;
  int ret = 0;

  if (identity[EI_CLASS] != ELFCLASS64) {
    warnx("invalid ELF class \"%s\"", ELF_CLASS_to_string(identity[EI_CLASS]));
    ret = -1;
    goto out;
  }

  mmap_min_addr += PAGE_SIZE;

  unsigned int i;
  Elf_Section_t** sections = elf_binary->sections;
  for (i = 0; i < header.numberof_sections; ++i) {
    Elf_Section_t* section = sections[i];
    if (section == NULL) {
      warnx("invalid section %d", i);
      ret = -1;
      goto out;
    }
    if (section->virtual_address != 0 &&
        section->virtual_address < mmap_min_addr + PAGE_SIZE) {
      warnx("invalid section \"%s\" (0x%lx)", section->name,
            section->virtual_address);
      ret = -1;
      goto out;
    }
  }

  Elf_Segment_t** segments = elf_binary->segments;
  for (i = 0; segments[i] != NULL; ++i) {
    Elf_Segment_t* segment = segments[i];
    if (segment->virtual_address != 0 &&
        segment->virtual_address < mmap_min_addr + PAGE_SIZE) {
      warnx("invalid segment (0x%lx)", segment->virtual_address);
      ret = -1;
      goto out;
    }
  }

out:
  elf_binary_destroy(elf_binary);
  return ret;
}

int main(void)
{
  unsigned long mmap_min_addr;
  char filename[PAGE_SIZE];
  int ret, status;
  pid_t pid;

  setbuf(stdin, NULL);
  setbuf(stdout, NULL);
  setbuf(stderr, NULL);

  system("/bin/ls -l .");

  if (get_mmap_min_addr(&mmap_min_addr) != 0)
    return EXIT_FAILURE;

  strncpy(filename, "/tmp/execve-sandbox-XXXXXX", sizeof(filename));

  puts("[*] waiting for an ELF binary...");
  if (recvfile(STDIN_FILENO, filename) != 0)
    return EXIT_FAILURE;

  if (elf_check(filename, mmap_min_addr) != 0) {
    ret = EXIT_FAILURE;
    goto out;
  }

  pid = fork();
  if (pid == -1) {
    warn("fork");
    ret = EXIT_FAILURE;
    goto out;
  }

  /* child */
  if (pid == 0)
    execute(filename, mmap_min_addr);

  /* parent */
  if (waitpid(pid, &status, 0) == -1) {
    warn("waitpid");
  } else {
    if (WIFSIGNALED(status) && WTERMSIG(status) == SIGSYS)
      puts("[*] \xc2\xaf\x5c\x5f\x28\xe3\x83\x84\x29\x5f\x2f\xc2\xaf");
  }

  ret = EXIT_SUCCESS;

out:
  if (unlink(filename) == -1)
    warn("unlink \"%s\" failed", filename);

  return ret;
}
