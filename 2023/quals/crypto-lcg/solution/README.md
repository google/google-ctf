# Google CTF 2023 - crypto: LCG writeup

The challenge implements a basic LCG to generate primes that are then used in the modulus that encrypts the flag. The program generates 8 primes that are 512 bits long.

The results are used to calculate the modulus and the totient. This information is then used to create the private key that will then encrypt the flag and write it to the text file.

There are two approaches to this challenge. The easiest approach is to factor out the modulus. Players can extract it via the .PEM file and then pass it through to a program like yafu for factorization. The total factoring time, however, is yet to be determined. I personally spent over an hour waiting for the prime to factor without much luck.

The intended approach is to have players figure out the missing values needed for the LCG to then generate the primes themselves and find the factors that way.

When looking at the code, we see that the value for the multiplier, the increment, and the modulus are all missing. We will need to implement some mathematical approach to get through this. There are plenty of resources when searching for "LCG CTF" that may help out with this.

We can use the first 10 consecutive values provided to us from the challenge to figure out the missing variables. We can manipulate the lcg equation `s_1 = s_0 * m + c (mod n)` to solve for the unknowns.

Starting from the last step, we can solve for the increment by modifying the original equation to the form `c = s_1 - s_0 * m (mod n)`. This requires the multiplier and the modulus to be known, so we can now create an equation to first figure out the multiplier.

Considering we have 10 consecutive values, we can use these to better aid the equation for the multiplier. The equation for the first two sequential values will be of the form `s_1 = s_0*m + c  (mod n)` and `s_2 = s_1*m + c  (mod n)`. We can manipulate these equations to then solve for the unknown values. Considering we have two unknowns, we have to solve for two equations, and as such we can derive `s_2 - s_1 = s_1 * m - s_0 * m (mod n)` and `s_2 - s_1 = m * (s_1 - s_0) (mod n)` to then put in terms of m as `m = (s_2 - s_1)/(s_1 - s_0) (mod n)`. Considering we are using modular division, we will need to implement the modular inverse of `s_1 - s_0` and the `modulus` through `pow(states[1] - states[0], -1, modulus)`.

Finally, we will need to solve for the modulus. A modulus from our orinal equation `s1 = s0*m + c (mod n)` can be presented as `s1 - (s0*m + c) = k_1 * n`. We will need to obtain the gcd from the values provided to be able to recover n since there is a large probability that their gcd will be equal to n. Additionally, it should be noted that `X = 0 (mod n) = k * n`. This essentially justifies that we would need to obtain the gcd from a sequence of values generated by the equation in order to find the modulus. We will need to create an equation for a sequence that uses the LCG to generate zeroes so we can then find n. The series `t_0 = s_1 - s_0`, `t_1 = s_2 - s_1 = (s_1 * m + c) - (s_0 * m + c) = m * (s_1 - s_0) = m * t_0 (mod n)`, `t_2 = s_3 - s_2 = (s_2 * m + c) - (s_1 * m + c) = m * (s_2 - s_1) = m * t_1 (mod n)` can be rewritten as `t_2 * t_0 - t_1 * t_1 = (m * m * t_0 * t_0) - (m * t_0 * m * t_0) = 0 (mod n)` to generate values congruent to zero to then find the modulus. This is the final piece to the LCG puzzle as the result from this can be used to find the multiplier and eventually land on the increment.

Now that we have the necessary values for the LCG, we can plug them in to the equation from the given `generate.py` script to obtain the primes used for the modulus. The 'e' can be extracted from the .PEM file and the values from this can be used to calculate the private key and decrypt the flag.
