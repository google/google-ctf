// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"crypto/rand"
	"encoding/hex"
	"testing"
	"time"
)

const numTests = 20

// TestGenerateSecret checks whether a secret generated by generateSecret is then
// correctly parsed by parseSecret.
func TestGenerateSecret(t *testing.T) {
	testCases := []struct{ isAdmin bool }{{true}, {false}}
	for _, tc := range testCases {
		for i := 0; i < numTests; i++ {
			expirationTime := time.Now().Add(SECRET_EXPIRATION_TIME).Unix()
			secret := generateSecret(tc.isAdmin, uint64(expirationTime))
			if len(secret) != SECRET_LEN {
				t.Errorf("len(%q) == %v, expected: %v", secret, len(secret), SECRET_LEN)
			}
			valid, isAdmin := parseSecret(secret)
			if !valid || isAdmin != tc.isAdmin {
				t.Errorf("parseSecret(generateSecret(%v)) == (%v, %v), expected (%v, %v)",
					tc.isAdmin, valid, isAdmin, true, tc.isAdmin)
			}
		}
	}
}

// TestGenerateSecretInThePast checks that tokens with expiration time in the past
// are invalid.
func TestGenerateSecretInThePast(t *testing.T) {
	for i := 0; i < numTests; i++ {
		expirationTime := time.Now().Add(-1 * time.Second).Unix()
		secret := generateSecret(false, uint64(expirationTime))
		if len(secret) != SECRET_LEN {
			t.Errorf("len(%q) == %v, expected: %v", secret, len(secret), SECRET_LEN)
		}
		valid, isAdmin := parseSecret(secret)
		if valid || isAdmin {
			t.Errorf("parseSecret(generateSecret(%v)) == (%v, %v), expected (%v, %v)",
				false, valid, isAdmin, false, false)
		}
	}

}

// TestParseSecretRandom checks whether giving random tokens to parseSecret returns
// valid == false.
func TestParseSecretRandom(t *testing.T) {
	for i := 0; i < numTests; i++ {
		r := make([]byte, SECRET_LEN)
		rand.Read(r)
		secret := hex.EncodeToString(r)
		valid, isAdmin := parseSecret(secret)
		if valid || isAdmin {
			t.Errorf("parseSecret(%v) == (%v, %v), expected (%v, %v)",
				secret, valid, isAdmin, false, false)
		}
	}
}
